#Задание 1

"""
Дан список с визитами по городам и странам.
Напишите код, который возвращает отфильтрованный список geo_logs, содержащий только визиты из России.
Считайте, что список geo_logs легко помещается в оперативной памяти.
"""

geo_logs = [
{'visit1': ['Москва', 'Россия']},

{'visit2': ['Дели', 'Индия']},

{'visit3': ['Владимир', 'Россия']},

{'visit4': ['Лиссабон', 'Португалия']},

{'visit5': ['Париж', 'Франция']},

{'visit6': ['Лиссабон', 'Португалия']},

{'visit7': ['Тула', 'Россия']},

{'visit8': ['Тула', 'Россия']},

{'visit9': ['Курск', 'Россия']},

{'visit10': ['Архангельск', 'Россия']},
]

#Для каждого визита из списка
for logs in geo_logs:
    #Для ключа в списке
    for k in logs:
        #Если значение страны(2 элемента в массиве значений) == 'Россия'
        if logs[k][1] == 'Россия':
            #Выводим данные об этом визите
            print(logs)

"""
Вывод:
{'visit1': ['Москва', 'Россия']}
{'visit3': ['Владимир', 'Россия']}
{'visit7': ['Тула', 'Россия']}
{'visit8': ['Тула', 'Россия']}
{'visit9': ['Курск', 'Россия']}
{'visit10': ['Архангельск', 'Россия']}
"""

#Задание 2

"""
Выведите на экран все уникальные гео-ID из значений словаря ids.
Т. е. список вида [213, 15, 54, 119, 98, 35]
"""

ids = {'user1': [213, 213, 213, 15, 213], 'user2': [54, 54, 119, 119, 119], 'user3': [213, 98, 98, 35]}
ids = {'user1': [213, 213, 213, 15, 213], 'user2': [54, 54, 119, 119, 119], 'user3': [213, 98, 98, 35]}

#Создаем массив, в который запишем все значения гео-ID
summary = []

#С помощью цикла запишем все значения в список summary
for k in ids:
    summary+=ids[k]

#Вывод уникальных значений из списка summary при помощи функции set
print(set(summary))

"""
Вывод:
{98, 35, 15, 213, 54, 119}
"""

#Задание 3

"""
Список поисковых запросов. Получить распределение количества слов в них.
Т. е. поисковых запросов из одного слова 5%, из двух - 7%, из трех - 3% итд.
"""

queries = [

'смотреть сериалы онлайн',

'новости спорта',

'афиша кино',

'курс доллара',

'сериалы этим летом',

'курс по питону',

'сериалы про спорт',

]

#Создаем словарь, в который будем записывать встретившиеся значения(как ключи) и кол-во этих значений
count_arr = {}
#Переменная, хранящаю в себе общее кол-во запросов
overall_sum_queries = len(queries)

#Цикл, который записывает в словарь кол-во слов в запросе(если такого кол-ва не было создает новый элемент и прибавляет 1 кол-ву встреч)
#Если же значение уже встречалось - просто прибавляет 1 к кол-ву встреч
for line in queries:
    count_arr.setdefault(len(line.split(' ')), 0)
    count_arr[len(line.split(' '))] += 1

#Вывод распределения кол-ва слов в запросах(процент округляется до 1-ой цифры после запятой)
for k in count_arr:
    print('{} слов(а) встретилось в {}% процентах случаев'.format(k,round((count_arr[k]/overall_sum_queries)*100,1)))

"""
Вывод:
3 слов(а) встретилось в 57.1% процентах случаев
2 слов(а) встретилось в 42.9% процентах случаев
"""


#Задание 4 *
"""
Дана статистика рекламных каналов по объемам продаж. Напишите скрипт, который возвращает название канала с максимальным объемом.

Т. е. в данном примере скрипт должен возвращать 'yandex'.
"""


stats = {'facebook': 55, 'yandex': 120, 'vk': 115, 'google': 99, 'email': 42, 'ok': 98}

#Создаем 2 массива
#Массив values будет содержать все значения, а names все имена
values = []
names = []


#Записываем имена и значения из stats в 2 созданных до этого массива
for k in stats:
    values.append(stats[k])
    names.append(k)

#Т.к. каждое значение в массиве values соответствует правильной компании в names(names[0]=='facebook', values[0]==55)
#То мы можем вывести наименование компании из списка names с индексом максимального элемента из списка values

print(names[values.index(max(values))])

"""
Вывод:
yandex
"""

#Задание 5 *
"""
Дан поток логов по количеству просмотренных страниц для каждого пользователя.
Список отсортирован по ID пользователя.
Вам необходимо написать алгоритм, который считает среднее значение просмотров на пользователя.
Т. е. надо посчитать отношение суммы всех просмотров к количеству уникальных пользователей.
Учтите, что весь список stream не помещается в оперативную память, т. е. его нужно обрабатывать поэлементно в цикле.
"""

stream = [

'2018-01-01,user1,3',

'2018-01-07,user1,4',

'2018-03-29,user1,1',

'2018-04-04,user1,13',

'2018-01-05,user2,7',

'2018-06-14,user3,4',

'2018-07-02,user3,10',

'2018-03-21,user4,19',

'2018-03-22,user4,4',

'2018-04-22,user4,8',

'2018-05-03,user4,9',

'2018-05-11,user4,11',

]

#Создаем словарь, в качестве ключей будет выступать имя user'а, а в качестве значения то, сколько раз этот user просмотрел страницу
strem = {}
#Создаем массив stream_arr, чтобы записать в него данные из stream в виде массивов(Строки будут разъединены запятой)
#Например, строка 2018,user,1 превратится в массив[2018,user,1]
stream_arr = []

#Заполняем массив stream_arr
for line in stream:
    stream_arr.append(line.split(','))

#Переменная, содержащая общее кол-во просмотров
cnt = len(stream)

#Заполняем словарь strem
for line in stream_arr:
    strem.setdefault(line[1], 0)
    strem[line[1]] += 1

#Выводим имя user'а : соотношение просмотров в виде просмотры пользователя/общее кол-во просмотров
for k in strem:
    print('{} : {}/{}'.format(k,strem[k],cnt))

"""
Вывод:
user1 : 4/12
user2 : 1/12
user3 : 2/12
user4 : 5/12
"""

#Задание 6 *

"""
Дана статистика рекламных кампаний по дням.
Напишите алгоритм, который по паре дата-кампания ищет значение численного столбца.
Т. е. для даты '2018-01-01' и 'google' нужно получить число 25.
Считайте, что все комбинации дата-кампания уникальны, а список stats легко помещается в оперативной памяти.
"""


stats = [

['2018-01-01', 'google', 25],

['2018-01-01', 'yandex', 65],

['2018-01-01', 'market', 89],

['2018-01-02', 'google', 574],

['2018-01-02', 'yandex', 249],

['2018-01-02', 'market', 994],

['2018-01-03', 'google', 1843],

['2018-01-03', 'yandex', 1327],

['2018-01-03', 'market', 1764],

]

#Создаем словарь, где в качестве ключа будет кортеж со значениями даты и названия компании
#А в качестве значения статистика

upd_stats = {}

#Записываем данные в словарь
for line in stats:
    upd_stats[(line[0],line[1])]=line[2]

#Вывод
upd_stats
